### 1.安装express

```shell
 npm init
 npm install express --save
```



### 2.运行

```shell
node main.js
```

```js
//nodejs修改文件后如何自动刷新

npm install nodemon -g
nodemon 启动文件名称
```



### 3.前端链接后台服务器

```js
				// 访问服务器
					uni.request({
						url:'http://192.168.24.11:3000/test',
						data:{},
						method:'GET',
						success:(data) => {
							console.log(data)
						}
					})
```



### 4. 允许跨域访问服务器

```js
//设置跨域访问
app.all('*', (req, res, next) => {
  res.header("Access-Control-Allow-Origin", "*");
  res.header("Access-Control-Allow-Headers", "Origin,X-Requested-With,Content-Type,Accept");
    res.header("Access-Control-Allow-Credentials", true);
  res.header("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS");
  res.header("X-Powered-By",' 3.2.1')
  res.header("Content-Type", "application/json;charset=utf-8");
   if (req.method == 'OPTIONS') {
        res.sendStatus(200)
    } else {
        next();
    }
});
```



+ 注意：这段代码需在载入路由之前

### 5.安装mongoose

```js
//启动mongodb
mongod

//查看
mongo

show dbs

use 数据库名称

show tables

//查看全部
db.名称.find()
```



### 6.创建数据表dbmodel.js

### 7.发送邮件

+ 安装`nodemailer`

```undefined
npm i nodemailer -s
```

+ 现在需要用来发送邮件的邮箱开启SMTP，取得邮箱 授权码

+ ```js
  //credentials.js
  module.exports = {
      //连接qq邮箱
      qq: {
          user: '1973443353@qq.com',
          pass: 'kuvsytsqppuifbgj',
  
      }
  }
  ```

+ 

+ ```js
  //emailserver.js
  // 引入发送邮件插件
  var nodemailer = require('nodemailer')
  // 引入证书文件
  var credentials = require('../config/credentials.js')
  
  // 创建传输方式
  var transporter = nodemailer.createTransport({
      service: 'qq',
      auth: {
          user: credentials.qq.user, // 发件人邮箱账号
          pass: credentials.qq.pass, //发件人邮箱的授权码 这里可以通过qq邮箱获取 并且不唯一
      }
  })
  
  // 注册发送邮件给用户
  exports.emailSignUp = function (email, res) {
      // 发送信息内容
      let options = {
          from: '1973443353@qq.com',
          to: email, //用户对方邮箱
          subject: '感谢注册！',
          html: '<span>欢迎加入你的加入</span><a href="http://localhost:8080/">点击</a>'
      }
  
      // 发送邮件
      transporter.sendMail(options, function (err, msg) {
          if (err) {
              res.send(err)
              console.log(err)
          } else {
              res.send('邮箱发送成功！')
              console.log('邮箱发送成功！')
          }
      })
  }
  ```

+ ```js
  //router/index.js
  // 引入邮箱发送方法
  var emailserver = require('../dao/emailserver.js')
  // 邮箱测试
  router.post('/mail', (req, res) => {
      // mail用户提交的邮箱
      let mail = req.body.mail
      emailserver.emailSignUp(mail, res)
  })
  ```

+ ```js
  //前端部分
  // 访问服务器
  					uni.request({
  						url:'http://192.168.24.11:3000/mail',
  						data:{
  							mail:this.user,
  						},
  						method:'POST',
  						success:(data) => {
  							console.log(data)
  						}
  					})
  ```

+ 

### 8.前端->后端路由->server处理函数->dbserver增删改->数据库

### 9.bcryptjs密码加密

```cmd
npm i bcryptjs
```

```js
//bcrypt.js
var bcrypt = require('bcryptjs')

//生成hash密码
exports.encryption = function (e) {
    //生成随机的salt
    let salt = bccypt.genSaltSync(10)

    //生成hash密码
    let hash = bcrypt.hashSync(e, salt)

    return hash
}

//解密
exports.verification = function (e, hash) {
    let verif = bcrypt.compareSync(e, hash)

    return verif
}
```



```js
//dbserver.js
// 密码加密
    let password = bcrypt.encryption(pwd)
```



### 10.创建新用户

```js
//dbserver.js
// 新建用户
exports.buildUser = function (name, mail, pwd, res) {
    // 密码加密
    let password = bcrypt.encryption(pwd)

    let data = {
        name: name,
        email: mail,
        psw: password,
        time: new Date(),
    }

    let user = new User(data)

    user.save(function (err, result) {
        if (err) {
            res.send({
                status: 500
            })
        } else {
            res.send({
                status: 200
            })
        }
    })
}
```



```js
//server/signup.js
var dbserver = require('../dao/dbserver.js')

//用户注册
exports.signUp = function (req, res) {
    let name = req.body.name
    let mail = req.body.mail
    let pwd = req.body.pwd

    //创建用户
    dbserver.buildUser(name, mail, pwd, res)

}

// 用户或邮箱是否占用判断
exports.judgeValue = function (req, res) {
    let data = req.body.data
    let type = req.body.type

    dbserver.countUserValue(data, type, res)
}
```

```js
//router/index.js
//引入注册页面服务
var signup = require('../server/signup.js')

router.post('/signup/add', (req, res) => {
    signup.signUp(req, res)
})

// 用户或邮箱是否占用判断
router.post('/signup/judge', (req, res) => {
    signup.judgeValue(req, res)
})
```

### 11.nodejs 基于token的身份验证

+ 实现免密登陆，就是基于token实现的

+ ### 基于token的验证原理

  - 不用将信息存储在服务器或者session中
  - token通过请求头传输，而不是把认证信息存储在服务器或者session中
  - 登陆时，客户端发送用户名密码
  2. 服务端验证用户名密码是否正确，校验通过就会生成一个有时效的token串，发送给客户端
  3. 客户端储存token,一般都会存储在localStorage或者cookie里面
  4. 客户端每次请求时都带有token，可以将其放在请求头里，每次请求都携带token
  5. 服务端验证token，所有需要校验身份的接口都会被校验token，若token解析后的数据包含用户身份信息，则身份验证通过，返回数据

 ## 12.node + jwt(jsonwebtoken) 搭建token身份验证

+ ```
  // 安装jsonwebtoken模块
  npm i jsonwebtoken 
  ```

+ ```js
  //dao/jwt.js
  //引入token
  var jwt = reqiure('jesonwebtoken')
  
  // 这是加密的key(密匙)
  let secret = 'hpc'
  
  //生成token
  exports.generateToken = function (id, res) {
      // 要生成token的主体信息
      let payload = {
          id: id,
          time: new Date()
      }
  
      let token = jwt.sign(payload, secret, {
          //时间过期
          expiresIn: 60 * 60 * 24 * 120
      })
  
      return token
  }
  
  // 解码token
  exports.verifyToken = function (e) {
      let payload = jwt.verify(e, secret,function (err, result) {
          if (err) {
              payload = 0
          } else {
              payload = 1
        }
      })
  
      return payload
  }
  ```
  
  ```js
  //dao/dbserver.js
  //引入token
  var jwt = require('../dao/jwt.js')
  
  // 用户验证
  exports.userMatch = function (data, pwd, res) {
  
      let wherestr = {
          $or: [{
              'name': data
          }, {
              'email': data
          }]
      }
  
      let out = {
          'name': 1,
          'imgurl': 1,
          'psw': 1
      }
  	//findOne()
      User.find(wherestr, out, function (err, result) {
          if (err) {
              res.send({
                  status: 500
              })
          } else {
              if (result == '') {
                  res.send({
                      status: 400
                  })
              }
  
              //找到对应的数据
              // map() 方法返回一个新数组， 数组中的元素为原始数组元素调用函数处理的后值,arr.map(function(currentValue，index，arr),thisValue)
              result.map(function (e) {
                  // 判断输入密码与存储的密码
                  const pwdMatch = bcrypt.verification(pwd, e.psw)
  
                  if (pwdMatch) {
  
                      let token = jwt.generateToken(e._id)
  
                      let back = {
                          id: e._id,
                          name: e.name,
                          imgurl: e.imgurl,
                          token: token,
                      }
  
                      res.send({
                          status: 200,
                          back
                      })
                  } else {
                      res.send({
                          status: 400
                      })
                  }
            })
  
          }
      })
  }
  ```
  
  ```js
  //server/sigin.js
  var dbserver = require('../dao/dbserver.js')
  
  //登录
  exports.signIn = function (req, res) {
    let data = req.body.data
      let pwd = req.body.pwd
  
      dbserver.userMatch(data, pwd, res)
  }
  ```
  
  ```js
  //router/index.js
  //引入登录页面服务
var signin = require('../server/signin.js')
  //登录页面
  router.post('/singin/match', (req, res) => {
      signin.signIn(req, res)
  })
  ```
  
  ```js
  前端测试
  
  // test(){
  			// 	uni.request({
  			// 		url:'http://192.168.24.11:3000/signin/test',
  			// 		data:{
  			// 			token:this.testToken
  			// 		},
  			// 		method:'POST',
  			// 		success:(data) => {
  						
  			// 			console.log(data)
  			// 		}
  			// 	})
  			// },
  			login(){//点击登录
  				if(this.user && this.pwd){
  					console.log('login!')
  					
  					// 访问服务器
  					uni.request({
  						url:'http://192.168.24.11:3000/signin/match',
  						data:{
  							data:'hahaha',
  							pwd:'123456',
  						},
  						method:'POST',
  						success:(data) => {
  							this.testToken = data.data.back.token
  							console.log(this.testToken)
  						}
  					})
  ```
  
  ```js
  //index.js
  
  // token判断
  app.use(function (req, res, next) {
      if (typeof (req.body.token) != 'undefined') {
          //处理token匹配
          let token = req.body.token
  
          let tokenMatch = jwt.verifyToken(token)
  
          //console.log('token---' + tokenMatch);
          //res.send({
              result: tokenMatch
          })
          
          if (tokenMatch == 1) {
              // 通过验证
              next()
          } else {
              // 验证不通过
              res.send({
                  status: 300
              })
          }
  
      } else {
          next()
      }
  })
  ```
  
  <img src="E:\练习例子\即时通讯\即刻通讯笔记\后端\后端\Snipaste_2020-09-07_01-02-52.jpg" alt="Snipaste_2020-09-07_01-02-52" style="zoom:50%;" />

<img src="E:\练习例子\即时通讯\即刻通讯笔记\后端\后端\Snipaste_2020-09-07_01-03-16.jpg" alt="Snipaste_2020-09-07_01-03-16" style="zoom:50%;" />

## 13.搜索用户

```js
$regex为模糊查询的字符串提供正则表达式功能
```

```js

//搜索用户
exports.searchUser = function (data, res) {
    let wherestr
    if (data == 'hpc') {
        wherestr = {}
    } else {
        wherestr = {
            $or: [{
                'name': {
                    // $regex为模糊查询的字符串提供正则表达式功能
                    $regex: data
                }
            }, {
                'email': {
                    $regex: data
                }
            }]
        }

    }

    let out = {
        'name': 1,
        'email': 1,
        'imgurl': 1,
    }

    User.find(wherestr, out, function (err, result) {
        if (err) {
            res.send({
                status: 500
            })
        } else {
            res.send({
                status: 200,
                result
            })
        }
    })
}
```



### 14.判断是否为好友

```js
// 好友
var Friend = dbmodel.model('Friend')

// 判断是否为好友
exports.isFriend = function (uid, fid, res) {

    let wherestr = {
        'userId': uid,
        'friendId': fid,
        'state': 0
    }

    Friend.findOne(wherestr, function (err, result) {
        if (err) {
            res.send({
                status: 500
            })
        } else {
            if (result) {
                // 为好友
                res.send({
                    status: 200
                })
            } else {
                // 不是好友
                res.send({
                    status: 400
                })
            }
        }
    })
}
```



### 15.搜索群

```js
// 群
var Group = dbmodel.model('Group')

// 搜索群
exports.searchGroup = function (data, res) {
    let wherestr
    if (data == 'hpc') {
       wherestr = {}
    } else {
       wherestr = {
            'name': {
                $regex: data
            }
        }
    }

    let out = {
        'name': 1,
        'imgurl': 1,
    }

    Group.find(wherestr, out, function (err, result) {
        if (err) {
            res.send({
                status: 500
            })
        } else {
            res.send({
                status: 200,
                result
            })
        }
    })
}
```





### 16.判断是否在群内

```js
// 群成员
var GroupMembers = dbmodel.model('GroupMembers')

//判断是否在群里
exports.isInGroup = function (uid, gid, res) {

    let wherestr = {
        'userId': uid,
        'groupId': gid
    }

    GroupMembers.findOne(wherestr, out, function (err, result) {
        if (err) {
            res.send({
                status: 500
            })
        } else {
            if (result) {
                // 在群内
                res.send({
                    status: 200
                })
            } else {
                // 不在群内
                res.send({
                    status: 400
                })
            }
        }
    })
}
```



### 17.处理搜索

```js
/server/search.js

var dbserver = require('../dao/dbserver')

//用户搜索
exports.searchUser = function (req, res) {
    let data = req.body.data

    dbserver.searchUser(data, res)
}

//判断是否为好友
exports.isFriend = function (req, res) {
    let uid = req.bofy.uid
    let fid = req.body.fid

    dbserver.isFriend(uid, fid, res)
}

//用户群
exports.searchGroup = function (req, res) {
    let data = req.body.data

    dbserver.searcGroup(data, res)
}

//判断是否在群内
exports.isInGroup = function (req, res) {
    let uid = req.bofy.uid
    let gid = req.body.gid

    dbserver.isInGroup(uid, gid, res)
}
```

```js
/router/index
// 引入搜素服务
var search = require('../server/search')

// 搜素页面
// 搜素用户
router.post('/search/user', (req, res) => {
    search.searchUser(req, res)
})

//判断是否为好友
router.post('/search/isfriend', (req, res) => {
    search.isFriend(req, res)
})

//搜索群
router.post('/search/group', (req, res) => {
    search.searchGroup(req, res)
})

//判断是否在群内
router.post('/search/isingroup', (req, res) => {
    search.isInGroup(req, res)
})
```



###18.用户详情

```js
// 用户详情
exports.userDetail = function (id, res) {
    let wherestr = {
        '_id': id
    }
    let out = {
        'psw': 0
    }

    User.findOne(wherestr, out, function (err, result) {
        if (err) {
            res.send({
                status: 500
            })
        } else {
            res.send({
                status: 200,
                result
            })
        }
    })
}
```

### 19.用户信息修改

```js
// 用户信息修改
exports.userUpdate = function (data, res) {
    let updatestr = {}

    // 判断是否有密码
    if (typeof (data.pwd) != 'undefined') {
        // 有密码进行匹配
        User.find({
            '_id': data.id
        }, {
            'psw':1
        }, function (err, result) {
            if (err) {
                res.send({
                    status: 500
                })
            } else {
                if (result == '') {
                    res.send({
                        status: 400
                    })
                }

                //找到对应的数据
                // map() 方法返回一个新数组， 数组中的元素为原始数组元素调用函数处理的后值,arr.map(function(currentValue，index，arr),thisValue)
                result.map(function (e) {
                    // 判断输入密码与存储的密码
                    // e.psw -> hash
                    const pwdMatch = bcrypt.verification(data.pwd, e.psw)

                    if (pwdMatch) {
                        // 密码验证成功

                        //如果为修改密码先加密
                        if (data.type == 'psw') {
                            // 密码加密
                            let password = bcrypt.encryption(data.data)

                            updatestr[data.type] = password
                        } else {
                            updatestr[data.type] = data.data
                        }

                        User.findByIdAndUpdate(data.id, updatestr, function (err, result) {
                            if (err) {
                                // 修改失败
                                res.send({
                                    status: 500
                                })
                            } else {
                                // 修改成功
                                res.send({
                                    status: 200
                                })
                            }
                        })

                    } else {
                        // 密码匹配失败
                        res.send({
                            status: 400
                        })
                    }
                })

            }
        })
    } else {
        // 没有密码进行匹配

        updatestr[data.type] = data.data

        User.findByIdAndUpdate(data.id, updatestr, function (err, result) {
            if (err) {
                // 修改失败
                res.send({
                    status: 500
                })
            } else {
                // 修改成功
                res.send({
                    status: 200
                })
            }
        })
    }

}
```



### 20.修改好友昵称

```js
// 修改好友昵称
exports.updateFriendNickName = function (data, res) {
    let wherestr = {
        'userId': data.uid,
        'friendId': data.fid
    }
    let updatestr = {
        'nickname': data.name,
    }

    Friend.updateOne(wherestr, updatestr, function (err, result) {
        if (err) {
            // 修改失败
            res.send({
                status: 500
            })
        } else {
            // 修改成功
            res.send({
                status: 200
            })
        }
    })
}
```



### 21.获取好友昵称

```js
// 获取好友昵称
exports.getFriendNickName = function (data, res) {
    let wherestr = {
        'userId': data.uid,
        'friendId': data.fid
    }
    let out = {
        'nickname': 1,
    }

    Friend.findOne(wherestr, out, function (err, result) {
        if (err) {
            // 修改失败
            res.send({
                status: 500
            })
        } else {
            // 修改成功
            res.send({
                status: 200,
                result
            })
        }
    })
}
```





### 22.用户详情数据处理

```js
//server/userdetail.js

var dbserver = require('../dao/dbserver.js')

// 详情
exports.userDetail = function (req, res) {
    let data = req.body.id

    dbserver.userDetail(data, res)
}

// 信息修改
exports.userUpdate = function (req, res) {
    let data = req.body

    dbserver.userUpdate(data, res)
}

// 修改好友昵称
exports.updateFriendNickName = function (req, res) {
    let data = req.body

    dbserver.updateFriendNickName(data, res)
}

// 获取好友昵称
exports.getFriendNickName = function (req, res) {
    let data = req.body

    dbserver.getFriendNickName(data, res)
}
```



```js
//router/index.js

// 引入用户详情页面服务
var user = require('../server/user/detail.js')

// 用户详情
router.post('/user/detail', (req, res) => {
    user.userDetail(req, res)
})

// 用户信息修改
router.post('/user/update', (req, res) => {
    user.userUpdate(req, res)
})

// 好友昵称修改
router.post('/user/updatenickname', (req, res) => {
    user.UpdateFriendNickName(req, res)
})

//获取好友昵称
router.post('/user/getnickname', (req, res) => {
    user.getFriendNickName(req, res)
})
```

### 23.用户信息修改优化

```js
// 用户信息修改
// 修改数据库
function userUpdate(data, update, res) {

    User.findByIdAndUpdate(data, update, function (err, result) {
        if (err) {
            // 修改失败
            res.send({
                status: 500
            })
        } else {
            // 修改成功
            res.send({
                status: 200
            })
        }
    })
}

exports.userUpdate = function (data, res) {
    let updatestr = {}

    // 1.判断是否有修改密码
    if (typeof (data.pwd) != 'undefined') {
        // 有密码进行匹配
        User.find({
            '_id': data.id
        }, {
            'psw': 1
        }, function (err, result) {
            if (err) {
                res.send({
                    status: 500
                })
            } else {
                if (result == '') {
                    res.send({
                        status: 400
                    })
                }

                //找到对应的数据
                // map() 方法返回一个新数组， 数组中的元素为原始数组元素调用函数处理的后值,arr.map(function(currentValue，index，arr),thisValue)
                result.map(function (e) {
                    // 判断密码与原存储的密码
                    // e.psw -> hash
                    const pwdMatch = bcrypt.verification(data.pwd, e.psw)

                    if (pwdMatch) {
                        // 密码验证成功

                        //如果为修改密码，先加密
                        if (data.type == 'psw') {
                            // 密码加密
                            let password = bcrypt.encryption(data.pwd)

                            updatestr[data.type] = password

                            userUpdate(data.id, updatestr, res)

                        } else {
                            //邮箱匹配

                            updatestr[data.type] = data.data

                            //更新的项目与数据库匹配是否存在相同，返回一个数字
                            User.countDocuments(updatestr, function (err, result) {
                                if (err) {
                                    res.send({
                                        status: 500
                                    })
                                } else {
                                    //没有匹配项，可以修改
                                    if (result == 0) {
                                        userUpdate(data.id, updatestr, res)
                                    } else {
                                        //邮箱已存在
                                        res.send({
                                            status: 600
                                        })
                                    }
                                }
                            })
                        }

                    } else {
                        // 密码匹配失败
                        res.send({
                            status: 400
                        })
                    }
                })

            }
        })
    } else if (data.type == 'name') {
        //2.如果是用户名先进行匹配

        updatestr[data.type] = data.data

        // 更新的用户名与原数据库匹配是否存在相同的用户名，返回一个数字
        User.countDocuments(updatestr, function (err, result) {
            if (err) {
                res.send({
                    status: 500
                })
            } else {
                //没有匹配项，可以修改
                if (result == 0) {
                    userUpdate(data.id, updatestr, res)
                } else {
                    //已存在
                    res.send({
                        status: 501
                    })
                }
            }
        })
    } else {
        // 3.一般项目修改
        // 没有密码进行匹配

        updatestr[data.type] = data.data

        userUpdate(data.id, updatestr, res)
    }

}
```

### 24.新建好友表

```js
// 新建好友表
exports.buildFriend = function (uid, fid, state, res) {

    let data = {
        userId: uid,
        friendId: fid,
        state: state,
        time: new Date(),
        lasttime: new Date()
    }

    let friend = new Friend(data)

    friend.save(function (err, result) {
        if (err) {
            // res.send({
            //     status: 500
            // })
            console.log('申请好友表出错！')
        } else {
            // res.send({
            //     status: 200
            // })
        }
    })
}
```

### 25.一对一消息表

```js
// 引入消息表
var Message = dbmodel.model('Message')

// 添加一对一消息
exports.inserMsg = function (uid, fid, msg, type, res) {

    let data = {
        userId: uid, //用户id
        friendId: fid, //接收者id
        message: msg, //发送内容
        types: type, //内容属性（0-> 文字，1->图片链接，2->音频链接，3->地图定位……）
        time: new Date(), //发送时间
        state: 1, //消息状态（0->已读，1->未读）
    }

    let message = new Message(data)

    message.save(function (err, result) {
        if (err) {
             if (res) {
                res.send({
                    status: 500
                })
            }
        } else {
            if (res) {
                res.send({
                    status: 200
                })
            }
        }
    })

}

```



### 26. 好友最后通讯时间

```js
// 好友最后通讯时间
exports.friendMsgLastTime = function (data) {
    let wherestr = {
        $or: [{
            'userId': data.uid,
            'friendId': data.fid
        }, {
            'userId': data.fid,
            'friendId': data.uid
        }]
    }

    let updatestr = {
        'lastTime': new Date()
    }

    Friend.updateMany(wherestr, updatestr, function (err, result) {
        if (err) {
            // res.send({
            //     status: 500
            // })
            console.log('好友最后通讯时间更新出错！')
        } else {
            // res.send({
            //     status: 200
            // })
        }
    })
}
```

### 27.申请好友

```js
// 申请好友
exports.applyFriend = function (data, res) {
    // 判断是否已经申请过
    let wherestr = {
        'userId': data.uid,
        'friendId': data.fid
    }

    // 匹配好友表
    Friend.countDocuments(wherestr, (err, result) => {
        if (err) {
            res.send({
                status: 500
            })
        } else {
            // 如果result = 0 为初次申请，创建新的好友表
            if (result == 0) {
                //好友状态（0->已为好友，1->申请中，2->申请发送对方，仍未同意）
                this.buildFriend(data.uid, data.fid, 2)
                this.buildFriend(data.fid, data.uid, 1)
            } else {
                // 已经申请过好友
                this.friendMsgLastTime(data.uid, data.fid)
                
            }

            // 添加一对一消息
            this.inserMsg(data.uid, data.fid, data.msg, 0, res)
        }
    })
}
```

```js
//server/friend.js

var dbserver = require('../dao/dbserver')

// 好友申请
exports.applyFriend = function (req, res) {
    let data = req.body

    dbserver.applyFriend(data, res)
}
```

```js
//router/index.js
// 引入申请好友页面服务
var friend = require('../server/friend.js')

// 好友操作
// 好友申请
router.post('/friend/applyfirend', (req, res) => {
    friend.applyFriend(req, res)
})
```



### 28.更新好友状态

```js
// 更新好友状态
exports.updateFriendState = function (data, res) {

    let wherestr = {
        $or: [{
            'userId': data.uid,
            'friendId': data.fid
        }, {
            'userId': data.fid,
            'friendId': data.uid
        }]
    }

    Friend.updateMany(wherestr, {
        'state': 0
    }, function (err, result) {
        if (err) {
            res.send({
                status: 500
            })

        } else {
            res.send({
                status: 200
            })
        }
    })

}
```

```js
// 更新好友状态
router.post('/friend/updateFriendState', (req, res) => {
    friend.updateFriendState(req, res)
})

```

```js
// 更新好友状态
exports.updateFriendState = function (req, res) {
    let data = req.body
    dbserver.updateFriendState(data, res)
}
```

### 29.拒绝或删除好友

```js

// 拒绝或删除好友
exports.deleteFriend = function (data, res) {

    let wherestr = {
        $or: [{
            'userId': data.uid,
            'friendId': data.fid
        }, {
            'userId': data.fid,
            'friendId': data.uid
        }]
    }

    Friend.deleteMany(wherestr, {
        'state': 0
    }, function (err, result) {
        if (err) {
            res.send({
                status: 500
            })

        } else {
            res.send({
                status: 200
            })
        }
    })

}
```



```js
// 拒绝或删除好友
router.post('/friend/deletefriend', (req, res) => {
    friend.deleteFriend(req, res)
})
```

```js
// 拒绝或删除好友
exports.deleteFriend = function (req, res) {
    let data = req.body
    dbserver.deleteFriend(data, res)
}
```



### 30.Multer 实现文件上传

+ https://github.com/expressjs/multer/blob/master/doc/README-zh-cn.md

- Multer 是一个 node.js 中间件，用于处理 `multipart/form-data` 类型的表单数据，它主要用于上传文件。它是写在 [busboy](https://github.com/mscdex/busboy) 之上非常高效。

**注意**: Multer 不会处理任何非 `multipart/form-data` 类型的表单数据。

+ 安装

```
$ npm install --save multer
```



- 基本使用方法:

```js
var express = require('express')
var multer  = require('multer')
var upload = multer({ dest: 'uploads/' })

var app = express()

app.post('/profile', upload.single('avatar'), function (req, res, next) {
  // req.file 是 `avatar` 文件的信息
  // req.body 将具有文本域数据，如果存在的话
})

app.post('/photos/upload', upload.array('photos', 12), function (req, res, next) {
  // req.files 是 `photos` 文件数组的信息
  // req.body 将具有文本域数据，如果存在的话
})

var cpUpload = upload.fields([{ name: 'avatar', maxCount: 1 }, { name: 'gallery', maxCount: 8 }])
app.post('/cool-profile', cpUpload, function (req, res, next) {
  // req.files 是一个对象 (String -> Array) 键是文件名，值是文件数组
  //
  // 例如：
  //  req.files['avatar'][0] -> File
  //  req.files['gallery'] -> Array
  //
  // req.body 将具有文本域数据，如果存在的话
})
```



### `storage`

#### 磁盘存储引擎 (`DiskStorage`)

磁盘存储引擎可以让你控制文件的存储。

```js
var storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, '/tmp/my-uploads')
  },
  filename: function (req, file, cb) {
    cb(null, file.fieldname + '-' + Date.now())
  }
})

var upload = multer({ storage: storage })
```

### 31.uni 上传 API

+ https://uniapp.dcloud.io/api/request/network-file?id=uploadfile

```js
uni.chooseImage({
    success: (chooseImageRes) => {
        const tempFilePaths = chooseImageRes.tempFilePaths;
        const uploadTask = uni.uploadFile({
            url: 'https://www.example.com/upload', //仅为示例，非真实的接口地址
            filePath: tempFilePaths[0],
            name: 'file',
            formData: {
                'user': 'test'
            },
            success: (uploadFileRes) => {
                console.log(uploadFileRes.data);
            }
        });

        uploadTask.onProgressUpdate((res) => {
            console.log('上传进度' + res.progress);
            console.log('已经上传的数据长度' + res.totalBytesSent);
            console.log('预期需要上传的数据总长度' + res.totalBytesExpectedToSend);

            // 测试条件，取消上传任务。
            if (res.progress > 50) {
                uploadTask.abort();
            }
        });
    }
});
```

### 32.创建文件目录

```js
// 新建目录
const fs = require('fs')
const path = require('path')

exports.mkdirs = (pathname, callback) => {
    //需要判断是否是绝对路径（避免不必要的bug）
    // Node.js 中，__dirname 总是指向被执行 js 文件的绝对路径
    pathname = path.isAbsolute(pathname) ? pathname : path.join(__dirname, pathname);
    // 获取相对路径
    // path.relative() 方法根据当前工作目录返回 from 到 to 的相对路径
    pathname = path.relative(__dirname, pathname)
    //(path.sep) 将特定文字分隔符 ‘\\' 或 ‘/' 的字符串转换成数组对象
    // windows 系统下的例子 : 'foo\\bar\\baz'.split(path.sep) --return-->   ['foo', 'bar', 'baz'] 
    //path.sep避免平台差异带来的bug
    let floders = pathname.split(path.sep) 

    let pre = ''

    floders.forEach(floder => {
        // try 测试代码块的错误，catch 语句处理错误，throw 创建并跑出错误。
        // try {//在这里运行代码，抛出错误}  catch(err) {//在这里处理错误}
        try {
            //没有异常，文件已经创建，提示用户更改文件已经创建
            // 获取文件信息：
            // 异步版的fs.stat(path, callback) 方法返回一个stat数组对象
            // 同步版 fs.statSync(path)
            // path.join 将路径片段使用特定的分隔符（window：\）连接起来形成路径，并规范化生成的路径
            let _stat = fs.statSync(path.join(__dirname, pre, floder)) 
            // fs.stats有以下方法:
            // stats.isFile()
            // stats.isDirectory()
            // stats.isBlockDevice()
            // stats.isCharacterDevice()
            // stats.isSymbolicLink() (only valid with fs.lstat())
            // stats.isFIFO()
            // stats.isSocket()
            let hasMkdir = _stat && _stat.isDirectory()
            if (hasMkdir) {
                callback //&&callback(`文件${floder}已经存在，不能重复创建，请重新创建`)
            }
        } catch (error) {
            //抛出异常，文件不存在则创建文件
            try {
                //避免父文件还没创建的时候先创建子文件所出现的意外bug，这里选择同步创建文件
                fs.mkdirSync(path.join(__dirname, pre, floder))
                callback && callback(null)
            } catch (error) {
                callback && callback(error)
            }
        }
        pre = path.join(pre, floder) //路径合并
    })
}

```



###33. 解析前端数据, 限制文件上传大小

+ app.use(bodyParser.urlencoded({limit:'50mb',extended:true}))

+ app.use(bodyParser.json({limit:'50mb'}))

###34.设置静态路径

```js
//将静态文件目录设置为：项目根目录 + '/public'
app.use(express.static(__dirname + '/public'))
//或者
app.use(express.static(path.join(__dirname,'public')))
```

###35.后端文件上传

```js
const express = require('express')
var router = express.Router()
// 引入附件上传插件
var multer = require('multer')
// 引入创建文件目录
var mkdir = require('../dao/mkdir')

// 控制文件存储
var storage = multer.diskStorage({
    destination: function (req, file, cb) {

        //前端提供给后端文件存储路径
        let url = req.body.url
        console.log('url:' + url)

        mkdir.mkdirs('../data/' + url,err=>{
            console.log(err)
        })

        // '/data/test'后端文件路径
        cb(null, './data/' + url)
    },
    filename: function (req, file, cb) {//上传文件名

        let name = req.body.name
        // 正则匹配后缀名
        let type = file.originalname.replace(/.+\./,".")
        console.log(name)
        cb(null, name + type)
    }
})

var upload = multer({
    storage: storage
})



// 前端文件上传
router.post('/files/upload', upload.array('file', 10), function (req,res, next) {
    // req.files 是 `file` 文件数组的信息
    // req.body 将具有文本域数据，如果存在的话
    // 获取文件名
    let name = req.files[0].filename
    // 返回给前端
    res.send(name)
})
    

module.exports = router
```

###36.上传文件前端部分

```js
<template>
	<view>
		<view class="upload" @tap="upload">上传图片</view>
		<image v-for="(item,index) in img" :key="index" :src="item" mode=""></image>
	</view>
</template>

<script>
	export default {
		data() {
			return {
				id:'ghjkasgdjagjd',
				img:[],
			}
		},
		methods: {
			upload:function(){  //上传、下载
				uni.chooseImage({
					
					  count: 9, //默认9
					  sizeType: ['original', 'compressed'], //可以指定是原图还是压缩图，默认二者都有
					  sourceType: ['album','camera'], //从相册选择
				    success: (chooseImageRes) => {
				        const tempFilePaths = chooseImageRes.tempFilePaths;
								
								// console.log(tempFilePaths)
								for(let i = 0;i < tempFilePaths.length; i ++){//for循环tempFilePaths上传多个
									
									const uploadTask = uni.uploadFile({
									    url: 'http://192.168.24.11:3000/files/upload', 
									    filePath: tempFilePaths[i],
									    name: 'file',
									    formData: {
									        url: 'user',
													name: new Date().getTime() + this.id + i,
									    },
									    success: (uploadFileRes) => {
													let path = 'user/' + uploadFileRes.data
													this.img.push('http://192.168.24.11:3000/' + path)
									        console.log(uploadFileRes.data);
									    }
									});
													
									uploadTask.onProgressUpdate((res) => {
									    console.log('上传进度' + res.progress);
									    // console.log('已经上传的数据长度' + res.totalBytesSent);
									    // console.log('预期需要上传的数据总长度' + res.totalBytesExpectedToSend);
													
									    // 测试条件，取消上传任务。
									    // if (res.progress > 50) {
									    //     uploadTask.abort();
									    // }
									});
									
								}
								  
				    }
				});
			},
		}
	}
</script>

<style lang="scss">
	.upload{
		padding-top:40rpx;
		text-align:center;
	}
</style>

```

###37.按要求获取用户列表

```js
//router/index.js
// 主页
var index = require('../server/index.js')


// 主页
// 获取好友
router.post('/index/getfriend',(req,res)=>{
    index.getFriend(req,res)
})

```

```js
//server/index.js
// 主页
var dbserver = require('../dao/dbserver')

// 获取好友列表
exports.getFriend = function(req,res){
     let data = req.body

    dbserver.getUsers(data,res)
}
```

```js
//dao/dbserver

//按要求获取用户列表
exports.getUsers = function(data,res){
    
    let query = Friend.find({})

    // 查询条件
    query.where({'userId':data.uid,'state':data.state})

    // 查找friendId关联的user对象
    // MongoDB是非关联数据库。但是有时候我们还是想引用其它的文档。这就是population的用武之地
    // 因为MongoDB是文档型数据库，所以它没有关系型数据库[joins](http://zh.wikipedia.org/wiki/连接_(SQL)(数据库的两张表通过"外键"，建立连接关系。) 特性。也就是在建立数据的关联时会比较麻烦。为了解决这个问题，Mongoose封装了一个Population功能。使用Population可以实现在一个 document 中填充其他 collection(s) 的 document(s)。
    // https://blog.csdn.net/qfxlw/article/details/84991715
    query.populate('friendId')

    // 排序方式 通讯时间倒叙排列
    // db.COLLECTION_NAME.find().sort({KEY:1,key2:-1});
    //  其中 1 为升序排列，而-1是用于降序排列.
    query.sort({'lastTime':-1})

    // 查询结果
    query.exec().then(function(e){
        // map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值
        let result = e.map(function(ver){
            return {
                id:ver.friendId._id,
                name:ver.friendId.name,
                nickname:ver.nickname,
                imgurl:ver.friendId.imgurl,
                lastTime:ver.lastTime
            }
        })

        res.send({status:200,result})

    }).catch(function(err){
        res.send({status:500})
    })
}
```

###38.按要求获取一对一消息

```js
//server/index.js
// 获取最后一条消息
exports.getLastMsg = function(req,res){
    let data = req.body
    dbserver.getOneMsg(data,res)
}
```

```js
//router/index

// 获取最后一条信息
router.post('/index/getlastmsg',(req,res)=>{
    index.getLastMsg(req,res)
})
```

```js
//dao/dbserver

//按要求获取一对一消息
exports.getOneMsg = function(data,res){
    
    let query = Message.findOne({})

    // 查询条件
    query.where({
        $or: [{
            'userId': data.uid,
            'friendId': data.fid
        }, {
            'userId': data.fid,
            'friendId': data.uid
        }]
    })

    // 排序方式 通讯时间倒叙排列
    query.sort({'time':-1})

    // 查询结果
    query.exec().then(function(ver){
    
        let result = {
            message:ver.message,
            time:ver.time,
            types:ver.types,
        }

        res.send({status:200,result})

    }).catch(function(err){
        res.send({status:500})
    })
}

```

### 39.汇总一对一消息未读数

```js
//router/index
// 汇总一对一消息未读数
router.post('/index/unreadmsg',(req,res)=>{
    index.unreadMsg(req,res)
})
```

```js
//server/index.js
// 获取好友未读消息数
exports.unreadMsg = function(req,res){
    let data = req.body
    dbserver.unreadMsg(data,res)
}
```

```js
//dao/dbserver
//汇总一对一消息未读数
exports.unreadMsg = function(data,res){
    // 汇总条件
    let wherestr = {
        'userId': data.fid,
        'friendId': data.uid,
        'state':1
    }

    // 匹配信息表
    Message.countDocuments(wherestr, (err, result) => {
        if (err) {
            res.send({
                status: 500
            })
        } else {
            res.send({status:200,result})
        }
    })
}
```

## 40.一对一消息状态修改

```js
//router/index
// 汇总一对一消息未读数
router.post('/index/updatemsg',(req,res)=>{
    index.updateMsg(req,res)
})
```

```js
//server/index.js
// 好友消息已读
exports.updateMsg = function(req,res){
    let data = req.body
    dbserver.updateMsg(data,res)
}
```

```js
//dao/dbserver
//一对一消息状态修改
exports.updateMsg = function(data,res){
    
    let wherestr = {
        'userId': data.uid,
        'friendId': data.fid,
        'state':1 //未读
    }

    let updatestr = {
        'state':0 //已读
    }

    Message.updateMany(wherestr,updatestr, (err, result) => {
        if (err) {
            res.send({
                status: 500
            })
        } else {
            res.send({status:200})
        }
    })
}
```

### 41.按要求获取群列表

```js
// 获取群列表
exports.getGroup = function(req,res){
    let uid = req.body.uid

    dbserver.getGroup(uid,res)
}
```

```js
// 获取群
router.post('/index/getgroup',(req,res)=>{
    index.getGroup(req,res)
})
```

```js
// 按要求获取群列表
exports.getGroup = function(uid,res){
    // id为用户，此用户所在群
    let query = GroupMembers.find({})

    // 查询条件
    query.where({'userId':uid})

    // 查找groupId关联
    query.populate('groupId')

    // 排序方式 通讯时间倒叙排列
    query.sort({'lastTime':-1})

    // 查询结果
    query.exec().then(function(e){
        
        let result = e.map(function(ver){
            return {
                id:ver.groupId._id,
                name:ver.groupId.name,
                nickname:ver.nickname,
                imgurl:ver.groupId.imgurl,
                lastTime:ver.lastTime,
                tip:ver.tip,
            }
        })

        res.send({status:200,result})

    }).catch(function(err){
        res.send({status:500})
    })
}
```



### 42.按要求获取群最后一条消息

```js
// 获取群最后一条消息
exports.getOneGroupMsg = function(req,res){
    let gid = req.body.gid
    dbserver.getOneGroupMsg(gid,res)
}
```

```js
// 获取群最后一条信息
router.post('/index/getlastgroupmsg',(req,res)=>{
    index.getOneGroupMsg(req,res)
})
```

```js
//按要求获取群最后一条消息
exports.getOneGroupMsg = function(gid,res){
    
    let query = GroupMessage.findOne({})

    // 查询条件
    query.where(
       {
        'groupId': gid,
        }
    )

    // 查找groupId关联的user对象
    query.populate('userId')

    // 排序方式 通讯时间倒叙排列
    query.sort({'time':-1})

    // 查询结果
    query.exec().then(function(ver){
    
        let result = {
            message:ver.message,
            time:ver.time,
            types:ver.types,
            name:ver.userId.name,
        }

        res.send({status:200,result})

    }).catch(function(err){
        res.send({status:500})
    })
}
```

### 43.群消息状态修改

```js
// 群消息已读
exports.updateMsgupdateGroupMsg = function(req,res){
    let data = req.body
    dbserver.updateGroupMsg(data,res)
}
```

```js
// 修改群消息未读数
router.post('/index/updategroupmsg',(req,res)=>{
    index.updateGroupMsg(req,res)
})
```

```js
//群消息状态修改
exports.updateGroupMsg = function(data,res){
    
    let wherestr = {
        'userId':data.uid,
        'groupId':data.fid, 
    }

    let updatestr = {
        'tip':0 
    }

    Message.updateOne(wherestr,updatestr, (err, result) => {
        if (err) {
            res.send({
                status: 500
            })
        } else {
            res.send({status:200})
        }
    })
}
```



## 44.分页获取数据一对一聊天数据

```js
//router/index.js

// 聊天页面
var chat = require('../server/chat.js')

//聊天页面
// 分页获取数据一对一聊天数据
router.post('/chat/msg',(req,res)=>{
    chat.msg(req,res)
})
```

```js
//server/chat.js
var dbserver = require('../dao/dbserver')

// // 分页获取数据一对一聊天数据
exports.msg = function (req, res) {
    let data = req.body
    dbserver.msg(data, res)
}
```

```js
//dbserver
// 消息操作
// 分页获取数据一对一聊天数据
exports.msg = function(data,res){

    // 跳过的条数
    var skipNum = data.nowPage * data.pageSize

    // id为用户，此用户所在群
    let query = Message.find({})

    // 查询条件
    query.where({
        $or: [{
            'userId': data.uid,
            'friendId': data.fid
        }, {
            'userId': data.fid,
            'friendId': data.uid
        }]
    })

    // 排序方式 通讯时间倒叙排列
    query.sort({'time':-1})

    // 查找关联
    query.populate('userId')

    // 跳过条数
    query.skip(skipNum)

    // 一页条数
    query.limit(data.pageSize)

    // 查询结果
    query.exec().then(function(e){
        
        let result = e.map(function(ver){
            return {
                id:ver._id,//数据独有的id
                message:ver.message,//信息
                types:ver.types,//信息属性//信息属性
                time:ver.time,//信息时间
                fromId:ver.userId._id,//信息来自哪里
                imgurl:ver.userId.imgurl,//发送者头像链接
            }
        })

        res.send({status:200,result})

    }).catch(function(err){
        res.send({status:500})
    })
}
```



##45.socket.io

+ 后端引入

```js
//先安装 npm i socket.io --save
//index.js
// Socket.io 
var server = app.listen(8082)
var io = require('socket.io').listen(server)
io.on('connextion',(socket)=>{
    console.log('a user connected~');
})
```

+ 下载weapp.cosket.io
  
- 将weapp.socket.io.js文件复制到前端组件
  
+ 将socket处理写到另一个文件中

  - ```js
    // Socket.io 
    var server = app.listen(8082)
    var io = require('socket.io').listen(server)
    require('./dao/socket')(io)
    ```

    

+ 每登录都链接一次

  - ```js
    onLoad() {
    		
    	 this.join(this.uid)
        this.socketTest()
    		},
    ```

  - ```js
    //socket模块
    			join(uid){//用户登录socket注册
    				this.socket.emit('login',uid)
    			},
                    socketTest(){//服务端消息接收测试
    				this.socket.on('msg',id=>{
    					console.log('服务端消息:'+id)
    				})
    			},
    ```

  - ```js
    module.exports = function (io) {
        
        // socket注册用户
            var users = {}
            
        io.on('connection', (socket) => {
            // console.log('a user connected');
    
           
            // 用户登录注册
            socket.on('login', (id) => {
                console.log(socket.id + '注册')
                // 回复客户端
                socket.emit('login', socket.id)
    
                socket.name = id
    
                users[id] = socket.id
    
    
            });
    
            // 用户离开
            socket.on('disconnecting', () => {
                console.log(users);
                // hasOwnProperty() 方法返回一个布尔值， 判断对象是否包含特定的自身（ 非继承） 属性
                if (users.hasOwnProperty(socket.name)) {
                    // 清空注册用户
                    delete users[socket.name]
                    console.log(users);
                }
    
                console.log(socket.id + '离开')
            })
        })
    }
    ```

## 45.socket提交

> 文字消息

+ 前端

```js
receiveMsg(msg,id,img,tip) { //接收的输入信息
// socket提交
				if(msg.types == 0){
					//发送给后端
					this.sendSocket(msg)
				}
}
```

```js
sendSocket(e){// 聊天数据发生后端
				if(this.type == 0){//0好友，1群
					// 1对1聊天
					
					this.socket.emit('msg',e,this.uid,this.fid)
				}else{
					//群消息
					this.socket.emit('groupMsg',e)
				}
			},
```



+ 后端

  

```js
//socket.js
// 用户1对1消息发送
        socket.on('msg', (msg, fromId, toId) => {
            console.log(msg)


        });
```

>图片

+ 前

```js
//正序插入图片
				if (msg.types == 1) {
					this.imgMsg.push(msg.message)
					
					// 当前日期文件夹
					let url = myfun.fileName(new Date())
					
					
					const uploadTask = uni.uploadFile({
						url: this.serverUrl + '/files/upload',
						filePath: msg.message,
						name: 'file',
						formData: {
							url: url,
							name: new Date().getTime() + this.uid + Math.ceil(Math.random()*10),//文件名字
						},
						success: (uploadFileRes) => {
							console.log(uploadFileRes);
							let data = {
								message:uploadFileRes.data,
								types:1,
							}
							
							this.sendSocket(data)
							
						}
					});

					uploadTask.onProgressUpdate((res) => {
						console.log('上传进度' + res.progress);
						// console.log('已经上传的数据长度' + res.totalBytesSent);
						// console.log('预期需要上传的数据总长度' + res.totalBytesExpectedToSend);

						// 测试条件，取消上传任务。
						// if (res.progress > 50) {
						//     uploadTask.abort();
						// }
					});
				}

```



>音频

+ 前

```js
// 提交音频
				if (msg.types == 2) {
			
					// 当前日期文件夹
					let url = myfun.fileName(new Date())
					
					const uploadTask = uni.uploadFile({
						url: this.serverUrl + '/files/upload',
						filePath: msg.message.voice,
						name: 'file',
						formData: {
							url: url,
							name: new Date().getTime() + this.uid + Math.ceil(Math.random()*10),//文件名字
						},
						success: (uploadFileRes) => {
							console.log(uploadFileRes);
							let data = {
								message:uploadFileRes.data,
								types:msg.types,
							}
							
							this.sendSocket(data)
							
						}
					});
				
					uploadTask.onProgressUpdate((res) => {
						console.log('上传进度' + res.progress);
						// console.log('已经上传的数据长度' + res.totalBytesSent);
						// console.log('预期需要上传的数据总长度' + res.totalBytesExpectedToSend);
				
						// 测试条件，取消上传任务。
						// if (res.progress > 50) {
						//     uploadTask.abort();
						// }
					});
				}
```



>位置

+ 前

```js
// 提交文字,地理位置
				if (msg.types == 0 || msg.types == 3) {……}
```



###46.一对一聊天数据发送

```js
receiveSocketMsg(){//Socket聊天数据接收
				this.socket.on('msg',(msg,fromId,tip)=>{
					if(fromId == this.fid && tip == 0){
						// 当前日期文件夹
						let url = myfun.fileName(new Date())
						
						this.scrollAnimation = true
						let len = this.msgs.length
						
						let nowTime = new Date()
						// 时间间隔
						let time = myfun.spaceTime(this.oldTime, nowTime)
						if (time) {
							this.oldTime = time
						}
						nowTime = time
						
						// console.log(msg)
						// 判断是否需要补充IP地址
						if(msg.types == 1 || msg.types == 2){
							msg.message = this.serverUrl + '/' + url + '/' + msg.message
						}
						
						let data = {
							fromId: fromId, //发送者id
							imgurl: this.f_imgurl,
							message: msg.message,
							types: msg.types, //(0:文字，1:图片，2:音频，3:地图)
							time: nowTime, //发送时间
							id: len,
						}
						
						this.msgs.push(data)
						
						if(msg.types == 1){
							// console.log(msg.message)
							this.imgMsg.push(msg.message)
						}
						
						// 定位到最新更新信息
						this.$nextTick(function() {
							this.scrollAnimation = false
							this.scrollToView = 'msg-' + len
						})
						this.goBottom()
					}
					console.log(msg+'来自:'+fromId)
					
					
					
				})
			},
```

```js

        // 用户1对1消息发送
        socket.on('msg', (msg, fromId, toId) => {
            console.log(msg)

            // 发送给对方 0 代表发给对方聊天页面渲染
          if (users[toId]) {
                socket.to(users[toId]).emit('msg', msg, fromId, 0)
            }

            // 发送给自己 1 代表发给自己首页渲染
            socket.emit('msg', msg, toId, 1)


        });
```

### 47.首页Socket聊天数据处理

```js
receiveSocketMsg(){//Socket聊天数据处理
				this.socket.on('msg',(msg,fromId)=>{
					// console.log(msg)
					let nmsg = ''
					
					if(msg.types == 0){
						nmsg = msg.message	
					}else if(msg.types == 1){
						nmsg = '[图片]'
					}else if(msg.types == 2){
						nmsg = '[音频]'
					}else if(msg.types == 3){
						nmsg = '[位置]'
					}
					
					// 首页消息列对比到对应项修改
					for(let i=0;i<this.friends.length;i++){
						if(this.friends[i].id == fromId){
							
							let e = this.friends[i]
							// console.log(e)
							e.lastTime = new Date()
							e.message = nmsg
							e.tip++
							// 删除原来的数据
							this.friends.splice(i,1)
							// 新消息插入到最顶部
							this.friends.unshift(e)
						}
					}
				})
			},
```



###48.存储一对一消息到数据库

```js
let dbserver = require('./dbserver')

//……
	// 修改好友最后通讯时间
            dbserver.friendMsgLastTime({
                uid: fromId,
                fid: toId
            })
            // 存储一对一消息
            dbserver.inserMsg(fromId, toId, msg.message, msg.types)


```

## 49.首页消息列表显示最新信息---发送方位置显示而接收方聊天页面却没有的问题

+ 由于发送的位置信息提交到后端为json格式而接收的聊天数据为字符串格式，所以不能显示

```js
//submit.vue
chooseLocation(e){//选择定位
				uni.chooseLocation({
				    success: (res) => {
							let data = {
								name:res.name,
								address:res.address,
								latitude:res.latitude,
								longitude:res.longitude
							}
							
							// json转json字符串
							let strData = JSON.stringify(data)
							
							this.handleSendMsg(strData,3)
				        // console.log('位置名称：' + res.name);
				        // console.log('详细地址：' + res.address);
				        // console.log('纬度：' + res.latitude);
				        // console.log('经度：' + res.longitude);
				    }
				});
			},
```

```js
getMsg() { //获取聊天数据 
    //……
								// json字符串还原
									if (msg[i].types ==3) {
										msg[i].message = JSON.parse(msg[i].message)
									
									}
```

```js
receiveMsg(msg, id, img, tip) { //接收输入信息			
				//tip == 0 表示自己发的，tip == 1

				// socket提交
				// 提交文字,地理位置
				if (msg.types == 0 || msg.types == 3) {
					//发送给后端
					this.sendSocket(msg)
				}
				
				// 提交图片
				//正序插入图片
				if (msg.types == 1 ) {
					this.imgMsg.push(msg.message)
					
					// 当前日期文件夹
					let url = myfun.fileName(new Date())
					
					
					const uploadTask = uni.uploadFile({
						url: this.serverUrl + '/files/upload',
						filePath: msg.message,
						name: 'file',
						formData: {
							url: url,
							name: new Date().getTime() + this.uid + Math.ceil(Math.random()*10),//文件名字
						},
						success: (uploadFileRes) => {
							console.log(uploadFileRes);
							let data = {
								message:uploadFileRes.data,
								types:msg.types,
							}
							
							this.sendSocket(data)
							
						}
					});
				
					uploadTask.onProgressUpdate((res) => {
						console.log('上传进度' + res.progress);
						// console.log('已经上传的数据长度' + res.totalBytesSent);
						// console.log('预期需要上传的数据总长度' + res.totalBytesExpectedToSend);
				
						// 测试条件，取消上传任务。
						// if (res.progress > 50) {
						//     uploadTask.abort();
						// }
					});
				}
				
				// 提交音频
				if (msg.types == 2) {
							
					// 当前日期文件夹
					let url = myfun.fileName(new Date())
					
					const uploadTask = uni.uploadFile({
						url: this.serverUrl + '/files/upload',
						filePath: msg.message.voice,
						name: 'file',
						formData: {
							url: url,
							name: new Date().getTime() + this.uid + Math.ceil(Math.random()*10),//文件名字
						},
						success: (uploadFileRes) => {
							console.log(uploadFileRes);
							let data = {
								message:uploadFileResda.data,
								types:msg.types,
							}
							
							this.sendSocket(data)
							
						}
					});
				
					uploadTask.onProgressUpdate((res) => {
						console.log('上传进度' + res.progress);
						// console.log('已经上传的数据长度' + res.totalBytesSent);
						// console.log('预期需要上传的数据总长度' + res.totalBytesExpectedToSend);
				
						// 测试条件，取消上传任务。
						// if (res.progress > 50) {
						//     uploadTask.abort();
						// }
					});
				}
				
				// 渲染
				this.scrollAnimation = true
				let len = this.msgs.length

				let nowTime = new Date()
				// 时间间隔
				let time = myfun.spaceTime(this.oldTime, nowTime)
				if (time) {
					this.oldTime = time
				}
				nowTime = time
				
				// json字符串还原
				if(msg.types == 3){
					msg.message = JSON.parse(msg.message)
				}

				let data = {
					fromId: id, //发送者id
					imgurl: img,
					message: msg.message,
					types: msg.types, //(0:文字，1:图片，2:音频，3:地图)
					time: nowTime, //发送时间
					id: len,
				}

				this.msgs.push(data)

				// 定位到最新更新信息
				this.$nextTick(function() {
					this.scrollAnimation = false
					this.scrollToView = 'msg-' + len
				})

				

			},
    
```

```js

```



##50.

